<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Clash Royale</title>
<style>
  body { margin:0; font-family:sans-serif; text-align:center; background:#a8e0ff; }
  canvas { background:#6fcf97; display:block; margin:0 auto; border:2px solid #333; }
  button { margin:5px; padding:10px; font-size:16px; }
  #cards { margin-top:10px; }
  .card { display:inline-block; width:60px; height:90px; margin:0 5px; background:#ccc; text-align:center; line-height:90px; cursor:pointer; user-select:none; }
</style>
</head>
<body>

<h1>Mini Clash Royale</h1>
<canvas id="game" width="800" height="400"></canvas>
<div id="cards">
  <div class="card" id="mini" draggable="true">Mini Person (2)</div>
  <div class="card" id="big" draggable="true">Big Person (3)</div>
  <div class="card" id="flying" draggable="true">Flying Skelly (2)</div>
</div>
<button onclick="resetGame()">Reset Game</button>
<div>Elixir: <span id="elixirDisplay">2</span></div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Game variables
let units = [];
let elixir = 2;
const maxElixir = 10;
let enemyTimer = 0;
const elixirRate = 2; // seconds per 1 elixir

// Towers
let towers;
function resetGame() {
  towers = {
    player: {
      princess1: { x: 100, y: 100, hp: 200 },
      princess2: { x: 100, y: 300, hp: 200 },
      king: { x: 100, y: 200, hp: 250 }
    },
    enemy: {
      princess1: { x: 700, y: 100, hp: 200 },
      princess2: { x: 700, y: 300, hp: 200 },
      king: { x: 700, y: 200, hp: 250 }
    }
  };
  units = [];
  elixir = 2;
  enemyTimer = 0;
  updateElixir();
}
resetGame();

// Card data
const cardData = {
  'mini': { type:'Mini Person', hp:5, damage:4, speed:1.5, flying:false, elixir:2 },
  'big': { type:'Big Person', hp:8, damage:2, speed:1, flying:false, elixir:3 },
  'flying': { type:'Flying Skelly', hp:4, damage:2, speed:2, flying:true, elixir:2 }
};

// Drag-and-drop deployment
const cards = document.querySelectorAll('.card');
cards.forEach(card => {
  card.addEventListener('dragstart', e => { e.dataTransfer.setData('text', card.id); });
});

canvas.addEventListener('dragover', e => e.preventDefault());
canvas.addEventListener('drop', e => {
  e.preventDefault();
  const cardId = e.dataTransfer.getData('text');
  const data = cardData[cardId];
  if(elixir >= data.elixir && e.offsetX < canvas.width/2){
    units.push({ ...data, x:e.offsetX, y:e.offsetY, side:'player' });
    elixir -= data.elixir;
    updateElixir();
  }
});

// Elixir regen
function updateElixir() { document.getElementById('elixirDisplay').innerText = elixir; }
setInterval(() => { elixir = Math.min(elixir+1, maxElixir); updateElixir(); }, elixirRate*1000);

// Game loop
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Draw water
  ctx.fillStyle='blue';
  ctx.fillRect(0, canvas.height/2 -50, canvas.width, 100);

  // Draw bridges
  ctx.fillStyle='brown';
  ctx.fillRect(0, canvas.height/2 -50, canvas.width, 20);
  ctx.fillRect(0, canvas.height/2 +30, canvas.width, 20);

  // Spawn enemy units
  enemyTimer += 1/60;
  if(enemyTimer >= 2){
    const choice = Math.random();
    if(choice<0.5) spawnEnemyUnit('mini');
    else spawnEnemyUnit('big');
    enemyTimer=0;
  }

  // Move units and handle combat
  units.forEach(u=>{
    // Move unit
    if(u.flying){ u.x += (u.side==='player'?1.5: -1.5); } 
    else {
      // Move along bridges
      if(u.y < canvas.height/2 -40) u.y = canvas.height/2 -40;
      else if(u.y > canvas.height/2 +40) u.y = canvas.height/2 +40;
      u.x += (u.side==='player'? u.speed : -u.speed);
    }

    // Attack enemy units first
    let attacked = false;
    units.forEach(other=>{
      if(other.side !== u.side){
        const dx = Math.abs(u.x - other.x);
        const dy = Math.abs(u.y - other.y);
        if(dx<20 && dy<20){
          if(u.type !== 'Big Person') u.hp -= 0.1; // Big Person ignores units
          other.hp -= u.damage * 0.1;
          attacked = true;
        }
      }
    });

    // Attack towers if no unit attacked
    if(!attacked){
      let targetTower;
      if(u.side==='player'){
        if((u.type!=='Flying Skelly' && u.x>towers.enemy.princess1.x-20) || (u.type!=='Flying Skelly' && u.x>towers.enemy.princess2.x-20)){
          // Logic: cannot attack king until princess fallen
          if(towers.enemy.princess1.hp>0) targetTower=towers.enemy.princess1;
          else if(towers.enemy.princess2.hp>0) targetTower=towers.enemy.princess2;
          else targetTower=towers.enemy.king;
        } else {
          targetTower=towers.enemy.princess1; // default
        }
      } else {
        if(u.type==='Big Person') targetTower=towers.player.princess1; // attacks towers only
        else targetTower=towers.player.princess1; // simple targeting
      }
      if(targetTower) targetTower.hp -= u.damage * 0.1;
    }
  });

  // Remove dead units
  for(let i=units.length-1;i>=0;i--){ if(units[i].hp<=0) units.splice(i,1); }

  // Draw towers
  function drawTower(tower,x,y,color){ ctx.fillStyle=color; ctx.fillRect(x-20,y-20,40,40); ctx.fillStyle='white'; ctx.fillText(tower.hp,x-15,y-25);}
  drawTower(towers.player.princess1,towers.player.princess1.x,towers.player.princess1.y,'blue');
  drawTower(towers.player.princess2,towers.player.princess2.x,towers.player.princess2.y,'blue');
  drawTower(towers.player.king,towers.player.king.x,towers.player.king.y,'darkblue');
  drawTower(towers.enemy.princess1,towers.enemy.princess1.x,towers.enemy.princess1.y,'red');
  drawTower(towers.enemy.princess2,towers.enemy.princess2.x,towers.enemy.princess2.y,'red');
  drawTower(towers.enemy.king,towers.enemy.king.x,towers.enemy.king.y,'darkred');

  // Draw units
  units.forEach(u=>{
    let color = 'yellow';
    if(u.type==='Big Person') color='red';
    if(u.type==='Flying Skelly') color='grey';
    ctx.fillStyle=color;
    ctx.fillRect(u.x-10,u.y-10,20,20);
  });

  requestAnimationFrame(draw);
}

// Spawn enemy unit helper
function spawnEnemyUnit(cardId){
  const data = cardData[cardId];
  units.push({ ...data, x:700, y:Math.random()>0.5?100:300, side:'enemy' });
}

draw();
</script>
</body>
</html>
