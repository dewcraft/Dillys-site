const maxElixir = 10;
let gameOver = false;
let suddenDeath = false;
let gameTimer = 0;
let suddenDeathTimer = 0;

// Drag variables
let dragging=false, currentCard=null, dragX=0, dragY=0;

// Towers
let towers;
function resetGame(){
  towers = {
    player: { princess1:{x:100,y:100,hp:200}, princess2:{x:100,y:300,hp:200}, king:{x:100,y:200,hp:250} },
    enemy: { princess1:{x:700,y:100,hp:200}, princess2:{x:700,y:300,hp:200}, king:{x:700,y:200,hp:250} }
  };
  units = [];
  elixir = 2;
  gameOver=false;
  suddenDeath=false;
  gameTimer=0;
  suddenDeathTimer=0;
  unlockedZones=[];
  updateElixir();
  updateTime();
}
resetGame();

// Card data
const cardData = {
  'mini': { type:'Mini Person', hp:15, damage:4, speed:1.5, flying:false, elixir:2 },
  'big': { type:'Big Person', hp:25, damage:2, speed:1, flying:false, elixir:3 },
  'flying': { type:'Flying Skelly', hp:15, damage:2, speed:2, flying:true, elixir:2 }
};

// Drag and drop
const cards = document.querySelectorAll('.card');
cards.forEach(card=>{
  card.addEventListener('dragstart', e=>{ currentCard=card.id; dragging=true; });
});
canvas.addEventListener('dragover', e=>{ e.preventDefault(); dragX=e.offsetX; dragY=e.offsetY; });
canvas.addEventListener('drop', e=>{
  e.preventDefault();
  dragging=false;
  if(!currentCard || !isValidDrop(e.offsetX,e.offsetY) || elixir<cardData[currentCard].elixir) return;
  const data = cardData[currentCard];
  let y = data.flying ? e.offsetY : (e.offsetY<canvas.height/2? canvas.height/2-15 : canvas.height/2+15);
  units.push({...data,x:e.offsetX,y,side:'player'});
  elixir -= data.elixir;
  updateElixir();
  aiQueue.push(currentCard);
});

// Elixir
let elixirCounter=0;
function updateElixir(){ document.getElementById('elixirDisplay').innerText=Math.floor(elixir); }

// Timer
function updateTime(){ document.getElementById('timeDisplay').innerText=Math.floor(gameTimer); }

// Enemy AI
let aiQueue=[];
let aiSpawnDelay=0;
function aiUpdate(){
  if(aiQueue.length>0 && aiSpawnDelay<=0){
    const cardId = aiQueue.shift();
    const data = cardData[cardId];
    const y = Math.random()>0.5?100:300;
    units.push({...data,x:700,y,side:'enemy'});
    aiSpawnDelay=3+Math.random()*2;
  }
  if(aiSpawnDelay>0) aiSpawnDelay -= 1/60;
}

// Tower draw
function drawTower(tower,x,y,color){
  if(tower.hp>0){ ctx.fillStyle=color; ctx.fillRect(x-20,y-20,40,40); }
  else{
    ctx.fillStyle='gray'; ctx.fillRect(x-20,y-20,40,40);
    ctx.strokeStyle='black'; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(x-20,y-20); ctx.lineTo(x+20,y+20);
    ctx.moveTo(x+20,y-20); ctx.lineTo(x-20,y+20);
    ctx.stroke();
  }
  ctx.fillStyle='white'; ctx.font='12px Arial'; ctx.fillText(Math.ceil(tower.hp),x-10,y-25);
}

// Unlocked zones for placement
let unlockedZones=[];
function updateUnlockedZones(){
  unlockedZones=[];
  if(towers.enemy.princess1.hp<=0) unlockedZones.push({x1:400,x2:800,y1:0,y2:200});
  if(towers.enemy.princess2.hp<=0) unlockedZones.push({x1:400,x2:800,y1:200,y2:400});
}

// Valid drop check
function isValidDrop(x,y){
  if(x<=canvas.width/2) return true;
  for(let zone of unlockedZones) if(x>=zone.x1 && x<=zone.x2 && y>=zone.y1 && y<=zone.y2) return true;
  return false;
}

// Main draw loop
function draw(){
  if(gameOver) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Water & bridges
  ctx.fillStyle='blue'; ctx.fillRect(0,canvas.height/2-20,canvas.width,40);
  ctx.fillStyle='brown';
  ctx.fillRect(0,canvas.height/2-20,canvas.width,10);
  ctx.fillRect(0,canvas.height/2+10,canvas.width,10);

  // Timers
  gameTimer+=1/60;
  updateTime();
  if(!suddenDeath && gameTimer>=60) suddenDeath=true;

  // Elixir regen
  let currentElixirRate=(suddenDeath)?1:(gameTimer>=30?1:2);
  elixirCounter+=1/60;
  if(elixirCounter>=currentElixirRate){ elixir=Math.min(elixir+1,maxElixir); elixirCounter=0; updateElixir(); }

  // AI
  aiUpdate();

  // Update unlocked zones
  updateUnlockedZones();

  // Units movement & combat
  units.forEach(u=>{
    if(u.flying) u.x += (u.side==='player'?u.speed:-u.speed);
    else { u.y=(u.y<canvas.height/2)?canvas.height/2-15:canvas.height/2+15; u.x+=(u.side==='player'?u.speed:-u.speed); }

    // Combat units
    units.forEach(o=>{
      if(o.side!==u.side){
        if(Math.abs(u.x-o.x)<20 && Math.abs(u.y-o.y)<20){
          if(u.type!=='Big Person') u.hp -= o.damage*0.1;
          o.hp -= u.damage*0.1;
        }
      }
    });

    // Combat towers
    let target=null;
    if(u.side==='player'){
      if(u.type==='Big Person'||!units.some(o=>o.side==='enemy')){
        target=(towers.enemy.princess1.hp>0)?towers.enemy.princess1:(towers.enemy.princess2.hp>0)?towers.enemy.princess2:towers.enemy.king;
      }
    } else{
      if(u.type==='Big Person'||!units.some(o=>o.side==='player')){
        target=(towers.player.princess1.hp>0)?towers.player.princess1:(towers.player.princess2.hp>0)?towers.player.princess2:towers.player.king;
      }
    }
    if(target){ target.hp-=u.damage*0.1; if(target.hp<0) target.hp=0; }
  });

  // Remove dead units
  for(let i=units.length-1;i>=0;i--){ if(units[i].hp<=0) units.splice(i,1); }

  // Draw towers
  drawTower(towers.player.princess1,towers.player.princess1.x,towers.player.princess1.y,'blue');
  drawTower(towers.player.princess2,towers.player.princess2.x,towers.player.princess2.y,'blue');
  drawTower(towers.player.king,towers.player.king.x,towers.player.king.y,'darkblue');
  drawTower(towers.enemy.princess1,towers.enemy.princess1.x,towers.enemy.princess1.y,'red');
  drawTower(towers.enemy.princess2,towers.enemy.princess2.x,towers.enemy.princess2.y,'red');
  drawTower(towers.enemy.king,towers.enemy.king.x,towers.enemy.king.y,'darkred');

  // Draw units
  units.forEach(u=>{
    let color='yellow'; if(u.type==='Big Person') color='red'; if(u.type==='Flying Skelly') color='grey';
    ctx.fillStyle=color; ctx.fillRect(u.x-10,u.y-10,20,20);
  });

  // Show forbidden areas when dragging
  if(dragging){
    ctx.fillStyle='rgba(0,0,0,0.3)';
    for(let x=canvas.width/2; x<canvas.width; x+=5){
      for(let y=0; y<canvas.height; y+=5){
        if(!isValidDrop(x,y)) ctx.fillRect(x,y,5,5);
      }
    }
  }

  // Sudden Death
  if(suddenDeath){
    if(towers.player.princess1.hp<=0||towers.player.princess2.hp<=0||towers.player.king.hp<=0){ gameOver=true; alert("AI Wins Sudden Death!"); return; }
    if(towers.enemy.princess1.hp<=0||towers.enemy.princess2.hp<=0||towers.enemy.king.hp<=0){ gameOver=true; alert("Player Wins Sudden Death!"); return; }
    suddenDeathTimer+=1/60;
    if(suddenDeathTimer>=30){ gameOver=true; alert("Tie!"); return; }
  } else {
    if(towers.player.king.hp<=0){ gameOver=true; alert("You Lose!"); return; }
    if(towers.enemy.king.hp<=0){ gameOver=true; alert("You Win!"); return; }
  }

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
