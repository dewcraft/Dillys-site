<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Clash Royale</title>
<style>
  body { margin:0; font-family:sans-serif; text-align:center; background:#a8e0ff; }
  canvas { background:#6fcf97; display:block; margin:0 auto; border:2px solid #333; }
  .card { display:inline-block; width:60px; height:90px; margin:0 5px; background:#ccc; text-align:center; line-height:90px; cursor:pointer; user-select:none; }
  #controls { text-align:center; margin-top:5px; }
  button { padding:10px; font-size:16px; vertical-align:top; }
</style>
</head>
<body>

<h1>Mini Clash Royale</h1>
<canvas id="game" width="800" height="400"></canvas>

<div id="controls">
  <div id="cards">
    <div class="card" id="mini" draggable="true">Mini Person (2)</div>
    <div class="card" id="big" draggable="true">Big Person (3)</div>
    <div class="card" id="flying" draggable="true">Flying Skelly (2)</div>
  </div>
  <button onclick="resetGame()">Reset Game</button>
  <span style="margin-left:20px;">Elixir: <span id="elixirDisplay">2</span></span>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let units = [];
let elixir = 2;
const maxElixir = 10;
let enemyTimer = 0;
const elixirRate = 2; // seconds per 1 elixir
let gameOver = false;

// Tower and bridge setup
let towers;
function resetGame() {
  towers = {
    player: {
      princess1: { x: 100, y: 100, hp: 200 },
      princess2: { x: 100, y: 300, hp: 200 },
      king: { x: 100, y: 200, hp: 250 }
    },
    enemy: {
      princess1: { x: 700, y: 100, hp: 200 },
      princess2: { x: 700, y: 300, hp: 200 },
      king: { x: 700, y: 200, hp: 250 }
    }
  };
  units = [];
  elixir = 2;
  enemyTimer = 0;
  gameOver = false;
  updateElixir();
}
resetGame();

// Card definitions
const cardData = {
  'mini': { type:'Mini Person', hp:15, damage:4, speed:1.5, flying:false, elixir:2 },
  'big': { type:'Big Person', hp:25, damage:2, speed:1, flying:false, elixir:3 },
  'flying': { type:'Flying Skelly', hp:15, damage:2, speed:2, flying:true, elixir:2 }
};

// Drag and drop cards
const cards = document.querySelectorAll('.card');
cards.forEach(card => {
  card.addEventListener('dragstart', e => { e.dataTransfer.setData('text', card.id); });
});

canvas.addEventListener('dragover', e => e.preventDefault());
canvas.addEventListener('drop', e => {
  e.preventDefault();
  const cardId = e.dataTransfer.getData('text');
  const data = cardData[cardId];
  if(elixir >= data.elixir && e.offsetX < canvas.width/2 && !gameOver){
    // Snap ground units to top/bottom bridge
    let y = e.offsetY;
    if(!data.flying){
      y = (y < canvas.height/2) ? canvas.height/2 -15 : canvas.height/2 +15;
    }
    units.push({ ...data, x:e.offsetX, y, side:'player' });
    elixir -= data.elixir;
    updateElixir();
  }
});

// Elixir regen
function updateElixir() { document.getElementById('elixirDisplay').innerText = elixir; }
setInterval(() => {
  if(!gameOver) { elixir = Math.min(elixir+1, maxElixir); updateElixir(); }
}, elixirRate*1000);

// Enemy spawn
function spawnEnemyUnit(cardId){
  const data = cardData[cardId];
  const y = Math.random()>0.5? 100 : 300;
  units.push({ ...data, x:700, y, side:'enemy' });
}

// Game loop
function draw() {
  if(gameOver) return;

  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Draw water (horizontal stream)
  ctx.fillStyle='blue';
  ctx.fillRect(0, canvas.height/2 -20, canvas.width, 40);

  // Draw narrow bridges
  ctx.fillStyle='brown';
  ctx.fillRect(0, canvas.height/2 -20, canvas.width, 10);
  ctx.fillRect(0, canvas.height/2 +10, canvas.width, 10);

  // Enemy AI spawn ~5 seconds
  enemyTimer += 1/60;
  if(enemyTimer >= 5){
    const choice = Math.random();
    if(choice<0.5) spawnEnemyUnit('mini');
    else spawnEnemyUnit('big');
    enemyTimer = 0;
  }

  // Move units and combat
  units.forEach(u => {
    if(u.flying){ u.x += (u.side==='player'? u.speed : -u.speed); }
    else{
      // Ground units snap to bridges
      u.y = (u.y < canvas.height/2) ? canvas.height/2 -15 : canvas.height/2 +15;
      u.x += (u.side==='player'? u.speed : -u.speed);
    }

    // Combat with enemy units
    units.forEach(other=>{
      if(other.side !== u.side){
        const dx = Math.abs(u.x - other.x);
        const dy = Math.abs(u.y - other.y);
        if(dx<20 && dy<20){
          if(u.type!=='Big Person') u.hp -= other.damage*0.1;
          other.hp -= u.damage*0.1;
        }
      }
    });

    // Attack towers if no unit blocking or Big Person
    let targetTower=null;
    if(u.side==='player'){
      if(u.type==='Big Person' || !units.some(ou=>ou.side==='enemy')){
        if(towers.enemy.princess1.hp>0) targetTower=towers.enemy.princess1;
        else if(towers.enemy.princess2.hp>0) targetTower=towers.enemy.princess2;
        else targetTower=towers.enemy.king;
      }
    } else {
      if(u.type==='Big Person' || !units.some(ou=>ou.side==='player')){
        if(towers.player.princess1.hp>0) targetTower=towers.player.princess1;
        else if(towers.player.princess2.hp>0) targetTower=towers.player.princess2;
        else targetTower=towers.player.king;
      }
    }
    if(targetTower){ targetTower.hp -= u.damage*0.1; if(targetTower.hp<0) targetTower.hp=0; }
  });

  // Remove dead units
  for(let i=units.length-1;i>=0;i--){ if(units[i].hp<=0) units.splice(i,1); }

  // Draw towers
  function drawTower(tower,x,y,color){
    if(tower.hp>0){
      ctx.fillStyle=color;
      ctx.fillRect(x-20,y-20,40,40);
    } else {
      ctx.fillStyle='gray';
      ctx.fillRect(x-20,y-20,40,40);
      ctx.strokeStyle='black';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(x-20,y-20); ctx.lineTo(x+20,y+20);
      ctx.moveTo(x+20,y-20); ctx.lineTo(x-20,y+20);
      ctx.stroke();
    }
    ctx.fillStyle='white';
    ctx.font='12px Arial';
    ctx.fillText(Math.ceil(tower.hp), x-10, y-25);
  }

  drawTower(towers.player.princess1,towers.player.princess1.x,towers.player.princess1.y,'blue');
  drawTower(towers.player.princess2,towers.player.princess2.x,towers.player.princess2.y,'blue');
  drawTower(towers.player.king,towers.player.king.x,towers.player.king.y,'darkblue');
  drawTower(towers.enemy.princess1,towers.enemy.princess1.x,towers.enemy.princess1.y,'red');
  drawTower(towers.enemy.princess2,towers.enemy.princess2.x,towers.enemy.princess2.y,'red');
  drawTower(towers.enemy.king,towers.enemy.king.x,towers.enemy.king.y,'darkred');

  // Draw units
  units.forEach(u=>{
    let color='yellow';
    if(u.type==='Big Person') color='red';
    if(u.type==='Flying Skelly') color='grey';
    ctx.fillStyle=color;
    ctx.fillRect(u.x-10,u.y-10,20,20);
  });

  // Check King Tower destruction
  if(towers.player.king.hp<=0){ gameOver=true; alert("You Lose!"); return; }
  if(towers.enemy.king.hp<=0){ gameOver=true; alert("You Win!"); return; }

  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
